### Java基本知识

* 基本概念
```
1. JVM, JRE, JDK的概念
  1) JVM（java Virtual Machine） java虚拟机
  
  2）JRE （java runtime environment）java运行环境（jvm + java程序运行的核心类库）
  
  3) JDK （java development kit） java开发工具包（java开发工具+jre）
  
2. JVM, JRE, JDK之间的关系
   
   JDK = JRE + 开发工具集
   JRE = JVM + Java SE标准类库
```
* java的命名规范
```
1. 包名：多单词组成时所有字母都小写： xxyyzz

2. 类名，接口名：多个单词组成时，所有单词的首字母大写：XxYyZz

3. 变量名，方法名：多个单词组成时，第一个单词首字母小写，第二个单词开始首字母大写：xxxYyyZzz

4. 常量名：所有字母都大写。多个单词时，每个单词用下划线连接：XXX_YYY_ZZZ
```
* java的数据类型
```
1. 基本数据类型
    1）数值类型：
        （1）整数（byte（1字节=8位， -128-127）, short（2字节）, int（4字节）, long（8字节））
        （2）浮点（float（4字节，有效数字精确7位）, dobule（8字节））
    
    2) 字符类型：char（1字符 = 2字节）
    
    3）布尔类型：boolean

2. 引用数据类型
    1）类：class
    
    2）接口：interface
    
    3）数组
```
* 逻辑运算操作
```
1. 位操作
   1） 左位移 相当于直接乘以 *2^n，其中n是位移的位数  5 << 1

   2） 右位移 相当于直接除以 /2^n 取整，其中n是位移的位数 5 >> 1

2. 逻辑与运算“&”
   1&1 = 1  1 & 0 = 0  0 & 1 = 0 0 & 0 = 0
   与逻辑“&&”之间的区别是：当符号左边的是false时，&继续执行符号右边的运算。&&不再执行符号右边的运算
   
3. 逻辑异或 
    1^0 = 1  1 ^ 1 = 0  0 ^ 0 = 0

4. a++与++a之间的区别
   b = a++ 表示先把a的值付给b，然后，a再加1，所以， b = 1
   b = ++a 表示先把a的值加1，然后再给b，所以 b = 2
   
```
* 数组元素
```
1. 数组的初始化值
   1）数组元素是整型的：0
   2）数组元素是浮点型：0.0
   3）数组元素是char型的：0 或者 '\u0000',而非'0'
   4) 数组元素是引用数据类型： null
```
* JVM内存结构---类的解析
```
编译完程序以后，生成一个或者多个字节码文件，我们使用JVM中类的加载器

和解释器对生成的字节码文件进行解释运行。意味着，需要将字节码文件对应的

类加载到内存中，涉及到内存的解析。

虚拟机栈，即为平时提到的栈结构。我们将“局部变量”存储在栈结构中。

堆，我们平时将new出来的结构（比如：数组，对象）加载在堆空间中。

补充：对象的属性（非static的）加载在堆空间中。

方法区：类的加载信息，常量池，静态域
```
* 面向对象
```
1. 方法重载与重写：
    1）重载
    在一个类中，可以允许有一个以上的同名方法，但是，参数的个数或者参数的类型不一致
    
    （跟方法的权限[public, protected, private]，返回值类型，参数的变量名无关）
    
    2）重写
      子类继承父类以后，可以对父类中同名同参数的方法（非静态方法static），进行覆盖操作
      （1）子类重写的方法的权限修饰符不小于父类重写的方法修饰符
      （2）特殊情况，子类不能重写父类中声明为private的方法
      （3）子类重写方法的返回值类型要么相同，要么是其子类
      （4）子类重写方法抛出的异常类型不大于被重写的方法抛出的异常类型
      
    3）静态绑定和动态绑定
      （1）对于重载而言，在方法调用之前，编译器就知道了所要调用的具体方法，这称为“静态绑定”
      
      （2）对于多态，只有等到方法调用的那一刻，编译器才会知道所要调用的具体方法，这称为“动态绑定”
      
 2. Java的传值机制
     java是按照值传递的方式：
     1）如果参数是基本的数据类型，此时，实参赋给形参的是实参真实存储的数据值
     2）如果参数是引用数据类型，此时，实参赋给形参的是实参存储的数据地址值
     经典案例：
     public static void main(String[] args) {
        MyIndex.first();
    }
    public static  void first() {
        int i = 5;
        Value v = new Value();
        v.i = 25;
        second(v, i);//考察java的传递方式是值传递
        System.out.println(v.i);
    }
    public  static  void second(Value v, int i) {
        i = 0;
        v.i = 20;
        Value val = new Value();
        v = val;
        System.out.println(v.i + "  "+i);
    }
    class Value{
      int i = 15;
    }
    //结果是： 15  0
              20
```
* java四种访问权限修饰符
```
修饰符            类内部         同一个包         不同包的子类              同一个工程
private            yes            
(缺省)             yes             yes
protected          yes             yes              yes
public             yes             yes              yes                    yes

说明：
  对于class的权限修饰只可以用public和default(缺省)
  1）public 类可以在任意地方访问
  2）default类只可以被同一个包内部访问
  3）构造器的权限跟类的权限是一致的
```
* JavaBean
```
1. JavaBean 是一种java语言写成的可重用组件
2. 所谓JavaBean,是指符合如下标准的Java类：
   1）类是公共的
   2）有一个无参的公共构造器
   3）有属性，且对应的有get，set方法
```
* this关键字
```
1. this可以用来修饰，调用：
    属性， 方法，构造器

2. 一般情况下，调用属性和方法时，可以省略。特殊情况下，如果构造器或者方法的形参和类的属性同名时，
    我们就必须显式的使用“this.属性名”来表明调用的是变量属性，而非形参。
    
3. this调用构造器
   1）在类的构造器中，可以通过“this(形参列表)”方式，调用本类中其他的构造器
   2）构造器中不能通过“this(形参列表)”方式来调用自己
   3）规定：“this(形参列表)”必须放在调用构造器的行首
   4）构造器中最多只能声明一个“this(形参列表)”，来调用其他构造器
```
* extends继承
```
子类继承父类所有的方法和属性（包括私有方法和属性），只是由于父类的封装性

子类不能够直接调用

java只支持单继承
```
* super
```
super调用构造器
  1）必须声明在子构造器的行首
  2）在构造器的行首没有显式的声明“this（参数列表）”或者“super(参数列表)”，则默认调用是父类的
     空参构造器：super()
  3) 在类的构造器中，至少有一个类的构造器使用了“super(参数列表)”，调用父类的构造器
```
* 多态
```
1. 可以理解为一种事物的多种形态

2.对象的多态
  父类的引用指向子类的对象（或子类的对象赋给父类的引用）
  
3. 多态的使用：虚拟方法调用
   编译时，只能调用父类声明的方法；运行时，实际调用的是子类重写的方法
   总结：编译看左边，运行看右边
   
4. 多态使用的前提：
    1）类的继承关系
    2）方法的重写

5. 对象的多态性，只适用于方法，不适应于属性

6. 有了对象的多态性以后，内存中实际上市加载了子类持有的属性和方法，但是由于变量声明为父类类型，
   
   导致编译时，只能调用父类声明的属性和方法。子类持有的属性和方法不能调用。
   
7. 如何才能调用子类持有的属性和方法
   向下转型：使用强制类型转换符
   
8. 对于引用数据类型，比较的是两个引用数据变量的地址是否相同

9. 多态的实例变量的调用，都是来自的父类的，编译运行都看左边

10. 多态的经典例题
    public class ExecTest {

    public static void main(String[] args) {
        Base1 base = new Sub1();

        base.add(1,2,3);

        Sub1 sub = (Sub1)base;
        sub.add(1, 2, 3);

    }
  }

  class Base1 {
      public void add(int a, int... arr) {
          System.out.println("base1");
      }
  }

  class Sub1 extends Base1 {
      //默认数组和可变参数类型是相同的
      public void add(int a, int[] arr){
          System.out.println("sub_1");
      }
      public void add(int a, int b, int c) {
          System.out.println("sub_2");
      }
  }
   
```

